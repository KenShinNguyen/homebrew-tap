From 7ccb42a3e8ade74b00adffd3f0eaa7c79d6923d5 Mon Sep 17 00:00:00 2001
From: Collider LI <lhc199652@gmail.com>
Date: Fri, 5 May 2023 17:59:06 -0400
Subject: [PATCH] ao_coreaudio: stop audio unit after timeout to allow sleep

This commit attempts to fix the problem that mpv prevents sleep on Mac
while paused (#11617). It also affects libmpv clients.

This problem was introduced by commit 39f7f83, where AudioOutputUnitStop
was changed to AudioUnitReset to prevent Bluetooth audio lag during
seeking. However, coreaudiod keeps putting an assertion to prevent sleep
when the audio unit is active.

The proposed solution in this commit is to call AudioOutputUnitStop
after a timeout. If the audio unit is reset and not restarted during the
timeout, it indicates that the user paused the playback (rather than
seeking), and sleep should be allowed. A serial dispatch queue is
created to reset/start the audio unit and update related data structures
to avoid racing conditions.
---
 audio/out/ao_coreaudio.c | 72 ++++++++++++++++++++++++++++++++++++++--
 1 file changed, 70 insertions(+), 2 deletions(-)

diff --git a/audio/out/ao_coreaudio.c b/audio/out/ao_coreaudio.c
index ee8d63a81cd2..a3ff1857fd3d 100644
--- a/audio/out/ao_coreaudio.c
+++ b/audio/out/ao_coreaudio.c
@@ -27,6 +27,13 @@
 #include "ao_coreaudio_properties.h"
 #include "ao_coreaudio_utils.h"
 
+// The timeout for stopping the audio unit after being reset. This allows the
+// device to sleep after playback paused. The duration is chosen to match the
+// behavior of QuickTime.
+#define STOP_AUTO_UNIT_TIMEOUT 6 * NSEC_PER_SEC
+
+static void *ao_key = "ao";
+
 struct priv {
     AudioDeviceID device;
     AudioUnit audio_unit;
@@ -37,6 +44,13 @@ struct priv {
     AudioStreamID original_asbd_stream;
 
     bool change_physical_format;
+    // Whether the audio unit was (re)started after last reset. This is used to
+    // make sure only one check_stop is scheduled for consecutive restarts.
+    bool start_called;
+    // +1 on start, -1 on check_stop. If zero, the audio unit was not restarted
+    // during the stop timeout, and we can stop it.
+    int start_counts;
+    dispatch_queue_t queue;
 };
 
 static int64_t ca_get_hardware_latency(struct ao *ao) {
@@ -159,6 +173,10 @@ static int init(struct ao *ao)
     if (!init_audiounit(ao, asbd))
         goto coreaudio_error;
 
+    p->queue = dispatch_queue_create("mpv/coreaudio_check_stop",
+                                     DISPATCH_QUEUE_SERIAL);
+    dispatch_queue_set_specific(p->queue, ao_key, (void *)ao, NULL);
+
     return CONTROL_OK;
 
 coreaudio_error:
@@ -313,24 +331,73 @@ static bool init_audiounit(struct ao *ao, AudioStreamBasicDescription asbd)
     return false;
 }
 
-static void reset(struct ao *ao)
+static void check_stop(void * q) {
+    dispatch_queue_t queue = (dispatch_queue_t)q;
+    struct ao *ao = (struct ao *)dispatch_queue_get_specific(queue, ao_key);
+    // return if ao has been uninitialized
+    if (!ao) {
+        return;
+    }
+    struct priv *p = ao->priv;
+    p->start_counts--;
+    // if no more check_stop is scheduled, stop audio unit
+    if (p->start_counts == 0) {
+        MP_VERBOSE(ao, "stopping audio unit after timeout");
+        OSStatus err = AudioOutputUnitStop(p->audio_unit);
+        CHECK_CA_WARN("can't stop audio unit");
+    }
+}
+
+static void reset_p(void *q)
 {
+    dispatch_queue_t queue = (dispatch_queue_t)q;
+    struct ao *ao = (struct ao *)dispatch_queue_get_specific(queue, ao_key);
     struct priv *p = ao->priv;
     OSStatus err = AudioUnitReset(p->audio_unit, kAudioUnitScope_Global, 0);
     CHECK_CA_WARN("can't reset audio unit");
+
+    if (p->start_called) {
+        dispatch_after_f(dispatch_time(DISPATCH_TIME_NOW, STOP_AUTO_UNIT_TIMEOUT),
+                         p->queue, p->queue, check_stop);
+    }
+    p->start_called = false;
 }
 
-static void start(struct ao *ao)
+static void reset(struct ao *ao)
 {
     struct priv *p = ao->priv;
+    dispatch_sync_f(p->queue, p->queue, reset_p);
+}
+
+static void start_p(void *ao_)
+{
+    struct ao *ao = (struct ao *)ao_;
+    struct priv *p = ao->priv;
+    p->start_counts++;
+    p->start_called = true;
     OSStatus err = AudioOutputUnitStart(p->audio_unit);
     CHECK_CA_WARN("can't start audio unit");
 }
 
+static void start(struct ao *ao)
+{
+    struct priv *p = ao->priv;
+    dispatch_sync_f(p->queue, ao, start_p);
+}
+
+static void uninit_p(void *ao_)
+{
+    struct ao *ao = (struct ao *)ao_;
+    struct priv *p = ao->priv;
+    dispatch_queue_set_specific(p->queue, ao_key, NULL, NULL);
+}
 
 static void uninit(struct ao *ao)
 {
     struct priv *p = ao->priv;
+    dispatch_sync_f(p->queue, ao, uninit_p);
+    dispatch_release(p->queue);
+
     AudioOutputUnitStop(p->audio_unit);
     AudioUnitUninitialize(p->audio_unit);
     AudioComponentInstanceDispose(p->audio_unit);
@@ -343,6 +410,7 @@ static void uninit(struct ao *ao)
     }
 }
 
+
 static OSStatus hotplug_cb(AudioObjectID id, UInt32 naddr,
                            const AudioObjectPropertyAddress addr[],
                            void *ctx)
