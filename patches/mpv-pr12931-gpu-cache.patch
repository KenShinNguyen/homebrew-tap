diff --git a/DOCS/man/options.rst b/DOCS/man/options.rst
index 36693c254f6f..d7d4258859b1 100644
--- a/DOCS/man/options.rst
+++ b/DOCS/man/options.rst
@@ -6819,7 +6819,10 @@ them.
     files contain uncompressed LUTs. Their size depends on the
     ``--icc-3dlut-size``, and can be very big.
 
-    NOTE: On ``--vo=gpu``, this is not cleaned automatically, so old, unused
+    On `--vo=gpu-next`, files that have not been accessed in the last 24 hours
+    may be cleared if the cache limit (64 MiB) is exceeded.
+
+    On ``--vo=gpu``, this is not cleaned automatically, so old, unused
     cache files may stick around indefinitely.
 
 ``--icc-cache-dir``
@@ -6968,11 +6971,14 @@ them.
 ``--gpu-shader-cache``
     Store and load compiled GLSL shaders in the cache directory (Default:
     ``yes``). Normally, shader compilation is very fast, so this is not usually
-    needed. It mostly matters for anything based on D3D11 (including ANGLE), as
-    well as on some other proprietary drivers. Enabling this can improve startup
-    performance on these platforms.
+    needed. It mostly matters for anything involving GLSL to SPIR-V conversion
+    D3D11 (including ANGLE) or Vulkan, as well as on some other proprietary
+    drivers. Enabling this can improve startup performance on these platforms.
+
+    On `--vo=gpu-next`, files that have not been accessed in the last 24 hours
+    may be cleared if the cache limit (64 MiB) is exceeded.
 
-    NOTE: On ``--vo=gpu``, is not cleaned automatically, so old, unused cache
+    On ``--vo=gpu``, this is not cleaned automatically, so old, unused cache
     files may stick around indefinitely.
 
 ``--gpu-shader-cache-dir``
diff --git a/video/out/vo_gpu_next.c b/video/out/vo_gpu_next.c
index 77ab0113bb66..243b804a9a06 100644
--- a/video/out/vo_gpu_next.c
+++ b/video/out/vo_gpu_next.c
@@ -17,6 +17,9 @@
  * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <dirent.h>
+#include <sys/stat.h>
+#include <time.h>
 #include <unistd.h>
 
 #include <libplacebo/colorspace.h>
@@ -90,9 +93,12 @@ struct frame_info {
 };
 
 struct cache {
-    char *path;
+    struct mp_log *log;
+    struct mpv_global *global;
+    char *dir;
+    const char *name;
+    size_t size_limit;
     pl_cache cache;
-    uint64_t sig;
 };
 
 struct priv {
@@ -1515,84 +1521,216 @@ static void wait_events(struct vo *vo, int64_t until_time_ns)
     }
 }
 
-#if PL_API_VER < 342
-static inline void xor_hash(void *hash, pl_cache_obj obj)
+static char *cache_filepath(void *ta_ctx, char *dir, const char *prefix, uint64_t key)
 {
-    *((uint64_t *) hash) ^= obj.key;
+    bstr filename = {0};
+    bstr_xappend_asprintf(ta_ctx, &filename, "%s_%016" PRIx64, prefix, key);
+    if (!filename.len)
+        return NULL;
+    return mp_path_join_bstr(ta_ctx, bstr0(dir), filename);
 }
 
-static inline uint64_t pl_cache_signature(pl_cache cache)
+static void cache_save_file(void *ta_ctx, char *filepath, void *data, size_t size)
 {
-    uint64_t hash = 0;
-    pl_cache_iterate(cache, xor_hash, &hash);
-    return hash;
+    if (!data || !size)
+        return;
+
+    char *tmp = talloc_asprintf(ta_ctx, "%sXXXXXX", filepath);
+    int fd = mkstemp(tmp);
+    if (fd < 0)
+        return;
+    FILE *cache = fdopen(fd, "wb");
+    if (!cache) {
+        close(fd);
+        unlink(tmp);
+        return;
+    }
+    size_t written = fwrite(data, size, 1, cache);
+    int ret = fclose(cache);
+    if (written > 0 && !ret) {
+        ret = rename(tmp, filepath);
+    } else {
+        unlink(tmp);
+    }
+}
+
+static pl_cache_obj cache_load_obj(void *p, uint64_t key)
+{
+    struct cache *c = p;
+    void *ta_ctx = talloc_new(NULL);
+    pl_cache_obj obj = {0};
+
+    if (!c->dir)
+        goto done;
+
+    char *filepath = cache_filepath(ta_ctx, c->dir, c->name, key);
+    if (!filepath)
+        goto done;
+
+    if (stat(filepath, &(struct stat){0}))
+        goto done;
+
+    int64_t load_start = mp_time_ns();
+    struct bstr data = stream_read_file(filepath, ta_ctx, c->global, 1000000000);
+    int64_t load_end = mp_time_ns();
+    MP_DBG(c, "%s: key(%" PRIx64 "), size(%zu), load time(%.3f ms)\n",
+           __func__, key, data.len,
+           MP_TIME_NS_TO_MS(load_end - load_start));
+
+    obj = (pl_cache_obj){
+        .key = key,
+        .data = talloc_steal(NULL, data.start),
+        .size = data.len,
+        .free = talloc_free,
+    };
+
+done:
+    talloc_free(ta_ctx);
+    return obj;
+}
+
+static void cache_save_obj(void *p, pl_cache_obj obj)
+{
+    const struct cache *c = p;
+    void *ta_ctx = talloc_new(NULL);
+
+    if (!c->dir)
+        goto done;
+
+    char *filepath = cache_filepath(ta_ctx, c->dir, c->name, obj.key);
+    if (!filepath)
+        goto done;
+
+    // Don't save if already exists
+    if (!stat(filepath, &(struct stat){0})) {
+        MP_DBG(c, "%s: key(%"PRIx64"), size(%zu)\n", __func__, obj.key, obj.size);
+        goto done;
+    }
+
+    int64_t save_start = mp_time_ns();
+    cache_save_file(ta_ctx, filepath, obj.data, obj.size);
+    int64_t save_end = mp_time_ns();
+    MP_DBG(c, "%s: key(%" PRIx64 "), size(%zu), save time(%.3f ms)\n",
+           __func__, obj.key, obj.size,
+           MP_TIME_NS_TO_MS(save_end - save_start));
+
+done:
+    talloc_free(ta_ctx);
 }
-#endif
 
 static void cache_init(struct vo *vo, struct cache *cache, size_t max_size,
                        const char *dir_opt)
 {
     struct priv *p = vo->priv;
-    const char *name = cache == &p->shader_cache ? "shader.cache" : "icc.cache";
+    const char *name = cache == &p->shader_cache ? "shader" : "icc";
+    const size_t limit = cache == &p->shader_cache ? 64 << 20 : 512 << 20;
 
     char *dir;
     if (dir_opt && dir_opt[0]) {
-        dir = mp_get_user_path(NULL, p->global, dir_opt);
+        dir = mp_get_user_path(vo, p->global, dir_opt);
     } else {
-        dir = mp_find_user_file(NULL, p->global, "cache", "");
+        dir = mp_find_user_file(vo, p->global, "cache", "");
     }
     if (!dir || !dir[0])
-        goto done;
+        return;
 
     mp_mkdirp(dir);
-    cache->path = mp_path_join(vo, dir, name);
-    cache->cache = pl_cache_create(pl_cache_params(
-        .log = p->pllog,
-        .max_total_size = max_size,
-    ));
+    *cache = (struct cache){
+        .log        = p->log,
+        .global     = p->global,
+        .dir        = dir,
+        .name       = name,
+        .size_limit = limit,
+        .cache = pl_cache_create(pl_cache_params(
+            .log = p->pllog,
+            .get = cache_load_obj,
+            .set = cache_save_obj,
+            .priv = cache
+        )),
+    };
+}
 
-    FILE *file = fopen(cache->path, "rb");
-    if (file) {
-        int ret = pl_cache_load_file(cache->cache, file);
-        fclose(file);
-        if (ret < 0)
-            MP_WARN(p, "Failed loading cache from %s\n", cache->path);
-    }
+struct file_entry {
+    char *filepath;
+    size_t size;
+    time_t atime;
+};
 
-    cache->sig = pl_cache_signature(cache->cache);
-done:
-    talloc_free(dir);
+static int compare_atime(const void *a, const void *b)
+{
+    return (((struct file_entry *)b)->atime - ((struct file_entry *)a)->atime);
 }
 
 static void cache_uninit(struct priv *p, struct cache *cache)
 {
     if (!cache->cache)
-        goto done;
-    if (pl_cache_signature(cache->cache) == cache->sig)
-        goto done; // skip re-saving identical cache
+        return;
 
-    assert(cache->path);
-    char *tmp = talloc_asprintf(cache->path, "%sXXXXXX", cache->path);
-    int fd = mkstemp(tmp);
-    if (fd < 0)
-        goto done;
-    FILE *file = fdopen(fd, "wb");
-    if (!file) {
-        close(fd);
-        unlink(tmp);
+    void *ta_ctx = talloc_new(NULL);
+    struct file_entry *files = talloc_array(ta_ctx, struct file_entry, 0);
+    size_t num_files = 0;
+    assert(cache->dir);
+    assert(cache->name);
+
+    DIR *d = opendir(cache->dir);
+    if (!d)
         goto done;
+
+    struct dirent *dir;
+    while ((dir = readdir(d)) != NULL) {
+        char *filepath = mp_path_join(ta_ctx, cache->dir, dir->d_name);
+        if (!filepath)
+            continue;
+        struct stat filestat;
+        if (stat(filepath, &filestat))
+            continue;
+        if (!S_ISREG(filestat.st_mode))
+            continue;
+        bstr fname = bstr0(dir->d_name);
+        if (!bstr_eatstart0(&fname, cache->name))
+            continue;
+        if (fname.len != 17) // _%016x
+            continue;
+        MP_TARRAY_APPEND(ta_ctx, files, num_files,
+                         (struct file_entry){
+                             .filepath = filepath,
+                             .size     = filestat.st_size,
+                             .atime    = filestat.st_atime,
+                         });
     }
-    int ret = pl_cache_save_file(cache->cache, file);
-    fclose(file);
-    if (ret >= 0)
-        ret = rename(tmp, cache->path);
-    if (ret < 0) {
-        MP_WARN(p, "Failed saving cache to %s\n", cache->path);
-        unlink(tmp);
+    closedir(d);
+
+    if (!num_files)
+        goto done;
+
+    qsort(files, num_files, sizeof(struct file_entry), compare_atime);
+
+    time_t t = time(NULL);
+    MP_VERBOSE(p, "Cleaning %s cache directory", cache->name);
+    if (cache->size_limit)
+        MP_VERBOSE(p, " (limit: %zu B)", cache->size_limit);
+    MP_VERBOSE(p, ":\n");
+    size_t cache_size = 0;
+    size_t cache_limit = cache->size_limit ? cache->size_limit : SIZE_MAX;
+    for (int i = 0; i < num_files; i++) {
+        // Remove files that exceed the size limit but are older than one day.
+        // This allows for temporary maintaining a larger cache size while
+        // adjusting the configuration. The cache will be cleared the next day
+        // for unused entries. We don't need to be overly aggressive with cache
+        // cleaning; in most cases, it will not grow much, and in others, it may
+        // actually be useful to cache more.
+        cache_size += files[i].size;
+        double rel_use = difftime(t, files[i].atime);
+        bool rem = cache_size > cache_limit && rel_use > 60 * 60 * 24;
+        MP_VERBOSE(p, "%s %s | size: %9zu B | last used: %9d seconds ago - %s",
+               rem ? "Removing" : "Keeping", files[i].filepath, files[i].size,
+               (int)rel_use, ctime(&files[i].atime));
+        if (rem)
+            unlink(files[i].filepath);
     }
 
-    // fall through
 done:
+    talloc_free(ta_ctx);
     pl_cache_destroy(&cache->cache);
 }
 

From 7ba207650efde1474f99dd7c161149382b068727 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Kacper=20Michaj=C5=82ow?= <kasper93@gmail.com>
Date: Tue, 21 Nov 2023 08:32:21 +0100
Subject: [PATCH 2/2] io: add mp_save_file

Move from vo_gpu_next.c to io.c and return result.
---
 osdep/io.c              | 29 +++++++++++++++++++++++++++++
 osdep/io.h              |  1 +
 video/out/vo_gpu_next.c | 29 ++++-------------------------
 3 files changed, 34 insertions(+), 25 deletions(-)

diff --git a/osdep/io.c b/osdep/io.c
index bdf79f8894bd..7a32e9e9f67c 100644
--- a/osdep/io.c
+++ b/osdep/io.c
@@ -902,3 +902,32 @@ int mp_mkostemps(char *template, int suffixlen, int flags)
     errno = EEXIST;
     return -1;
 }
+
+bool mp_save_to_file(const char *filepath, const void *data, size_t size)
+{
+    assert(filepath && data && size);
+
+    bool result = false;
+    char *tmp = talloc_asprintf(NULL, "%sXXXXXX", filepath);
+    int fd = mkstemp(tmp);
+    if (fd < 0)
+        goto done;
+    FILE *cache = fdopen(fd, "wb");
+    if (!cache) {
+        close(fd);
+        unlink(tmp);
+        goto done;
+    }
+    size_t written = fwrite(data, size, 1, cache);
+    int ret = fclose(cache);
+    if (written > 0 && !ret) {
+        ret = rename(tmp, filepath);
+        result = !ret;
+    } else {
+        unlink(tmp);
+    }
+
+done:
+    talloc_free(tmp);
+    return result;
+}
diff --git a/osdep/io.h b/osdep/io.h
index db711fb2656f..ec8051ab3d3e 100644
--- a/osdep/io.h
+++ b/osdep/io.h
@@ -228,5 +228,6 @@ extern char **environ;
 #endif /* __MINGW32__ */
 
 int mp_mkostemps(char *template, int suffixlen, int flags);
+bool mp_save_to_file(const char *filepath, const void *data, size_t size);
 
 #endif
diff --git a/video/out/vo_gpu_next.c b/video/out/vo_gpu_next.c
index 243b804a9a06..7f68f985a53c 100644
--- a/video/out/vo_gpu_next.c
+++ b/video/out/vo_gpu_next.c
@@ -1530,30 +1530,6 @@ static char *cache_filepath(void *ta_ctx, char *dir, const char *prefix, uint64_
     return mp_path_join_bstr(ta_ctx, bstr0(dir), filename);
 }
 
-static void cache_save_file(void *ta_ctx, char *filepath, void *data, size_t size)
-{
-    if (!data || !size)
-        return;
-
-    char *tmp = talloc_asprintf(ta_ctx, "%sXXXXXX", filepath);
-    int fd = mkstemp(tmp);
-    if (fd < 0)
-        return;
-    FILE *cache = fdopen(fd, "wb");
-    if (!cache) {
-        close(fd);
-        unlink(tmp);
-        return;
-    }
-    size_t written = fwrite(data, size, 1, cache);
-    int ret = fclose(cache);
-    if (written > 0 && !ret) {
-        ret = rename(tmp, filepath);
-    } else {
-        unlink(tmp);
-    }
-}
-
 static pl_cache_obj cache_load_obj(void *p, uint64_t key)
 {
     struct cache *c = p;
@@ -1591,6 +1567,9 @@ static pl_cache_obj cache_load_obj(void *p, uint64_t key)
 
 static void cache_save_obj(void *p, pl_cache_obj obj)
 {
+    if (!obj.data || !obj.size)
+        return;
+
     const struct cache *c = p;
     void *ta_ctx = talloc_new(NULL);
 
@@ -1608,7 +1587,7 @@ static void cache_save_obj(void *p, pl_cache_obj obj)
     }
 
     int64_t save_start = mp_time_ns();
-    cache_save_file(ta_ctx, filepath, obj.data, obj.size);
+    mp_save_to_file(filepath, obj.data, obj.size);
     int64_t save_end = mp_time_ns();
     MP_DBG(c, "%s: key(%" PRIx64 "), size(%zu), save time(%.3f ms)\n",
            __func__, obj.key, obj.size,
