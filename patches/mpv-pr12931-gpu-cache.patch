From 1aea2229ec689de8d83fd46922d579116d4f5a4f Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Kacper=20Michaj=C5=82ow?= <kasper93@gmail.com>
Date: Wed, 13 Dec 2023 18:43:30 +0100
Subject: [PATCH 1/3] stream: increase max_size to INT_MAX minus padding

No need to magic number limit, we can support up to INT_MAX with current
code. Which should be more than enough.
---
 stream/stream.c | 11 +++++------
 stream/stream.h |  6 ++++++
 2 files changed, 11 insertions(+), 6 deletions(-)

diff --git a/stream/stream.c b/stream/stream.c
index dd67825dd58d..89b03e1f5575 100644
--- a/stream/stream.c
+++ b/stream/stream.c
@@ -803,18 +803,17 @@ int stream_skip_bom(struct stream *s)
 struct bstr stream_read_complete(struct stream *s, void *talloc_ctx,
                                  int max_size)
 {
-    if (max_size > 1000000000)
+    if (max_size <= 0 || max_size > STREAM_MAX_READ_SIZE)
         abort();
 
     int bufsize;
     int total_read = 0;
-    int padding = 1;
     char *buf = NULL;
     int64_t size = stream_get_size(s) - stream_tell(s);
     if (size > max_size)
         return (struct bstr){NULL, 0};
     if (size > 0)
-        bufsize = size + padding;
+        bufsize = size + STREAM_PADDING_SIZE;
     else
         bufsize = 1000;
     while (1) {
@@ -827,10 +826,10 @@ struct bstr stream_read_complete(struct stream *s, void *talloc_ctx,
             talloc_free(buf);
             return (struct bstr){NULL, 0};
         }
-        bufsize = MPMIN(bufsize + (bufsize >> 1), max_size + padding);
+        bufsize = MPMIN(bufsize + (bufsize >> 1), max_size + STREAM_PADDING_SIZE);
     }
-    buf = talloc_realloc_size(talloc_ctx, buf, total_read + padding);
-    memset(&buf[total_read], 0, padding);
+    buf = talloc_realloc_size(talloc_ctx, buf, total_read + STREAM_PADDING_SIZE);
+    memset(&buf[total_read], 0, STREAM_PADDING_SIZE);
     return (struct bstr){buf, total_read};
 }
 
diff --git a/stream/stream.h b/stream/stream.h
index 423ba12d9106..43fb8e79b415 100644
--- a/stream/stream.h
+++ b/stream/stream.h
@@ -32,6 +32,12 @@
 // it's guaranteed that you can seek back by <= of this size again.
 #define STREAM_BUFFER_SIZE 2048
 
+// Size of 0 byte padding. The padding is not included in the returned length.
+#define STREAM_PADDING_SIZE 1
+
+// Maximum size of a complete read.
+#define STREAM_MAX_READ_SIZE (INT_MAX - STREAM_PADDING_SIZE)
+
 // flags for stream_open_ext (this includes STREAM_READ and STREAM_WRITE)
 
 // stream->mode

From db6cc9d2f30492657a111d5e0db5c35cca07c557 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Kacper=20Michaj=C5=82ow?= <kasper93@gmail.com>
Date: Fri, 17 Nov 2023 19:31:51 +0100
Subject: [PATCH 2/3] vo_gpu_next: save cache to separate files

Save the cache to separate files to avoid loading/saving a huge combined
libplacebo.cache. This approach allows the saving of only new cache
objects and avoids resaving the entire cache, especially even if only a
tiny change was made.

This commit improves the cold start time of mpv and avoids saving data
when it's not necessary.

Number of changes were made:
- each cached object is saved in its own file
- cache files are prefixed with the name of cached object
- cache directory is cleaned on each uninit
    - the least recently used cache files are removed if cumulative cache
      size is above limit
    - files used in the recent 24 hours are not removed to allow changes
      to mpv.conf without worrying about the cache being removed during
      experimentation
- shader cache size limit is set to 128 MiB
- icc cache size limit is set to 1.5 GiB
- cache objects are loaded/saved as needed

This commit eliminates the runtime performance penalty associated with
the size cache. While we continue to maintain the cache limit to prevent
retaining stale objects, mpv now only loads a small subset of files that
are currently required for playback, instead of loading all files.
---
 DOCS/man/options.rst    |  18 ++--
 video/out/vo_gpu_next.c | 230 +++++++++++++++++++++++++++++++---------
 2 files changed, 193 insertions(+), 55 deletions(-)

diff --git a/DOCS/man/options.rst b/DOCS/man/options.rst
index dc9c568fa3bb..28602ab9614c 100644
--- a/DOCS/man/options.rst
+++ b/DOCS/man/options.rst
@@ -6838,8 +6838,11 @@ them.
     files contain uncompressed LUTs. Their size depends on the
     ``--icc-3dlut-size``, and can be very big.
 
-    NOTE: On ``--vo=gpu``, this is not cleaned automatically, so old, unused
-    cache files may stick around indefinitely.
+    On `--vo=gpu-next`, files that have not been accessed in the last 24 hours
+    may be cleared if the cache limit (1.5 GiB) is exceeded.
+
+    On ``--vo=gpu``, this is not cleaned automatically, so old, unused cache
+    files may stick around indefinitely.
 
 ``--icc-cache-dir``
     The directory where icc cache is stored. Cache is stored in the system's
@@ -6987,11 +6990,14 @@ them.
 ``--gpu-shader-cache``
     Store and load compiled GLSL shaders in the cache directory (Default:
     ``yes``). Normally, shader compilation is very fast, so this is not usually
-    needed. It mostly matters for anything based on D3D11 (including ANGLE), as
-    well as on some other proprietary drivers. Enabling this can improve startup
-    performance on these platforms.
+    needed. It mostly matters for anything involving GLSL to SPIR-V conversion,
+    that is: D3D11, ANGLE or Vulkan, as well as on some other proprietary
+    drivers. Enabling this can improve startup performance on these platforms.
+
+    On `--vo=gpu-next`, files that have not been accessed in the last 24 hours
+    may be cleared if the cache limit (128 MiB) is exceeded.
 
-    NOTE: On ``--vo=gpu``, is not cleaned automatically, so old, unused cache
+    On ``--vo=gpu``, this is not cleaned automatically, so old, unused cache
     files may stick around indefinitely.
 
 ``--gpu-shader-cache-dir``
diff --git a/video/out/vo_gpu_next.c b/video/out/vo_gpu_next.c
index 77ab0113bb66..8a109950630a 100644
--- a/video/out/vo_gpu_next.c
+++ b/video/out/vo_gpu_next.c
@@ -17,6 +17,9 @@
  * License along with mpv.  If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include <dirent.h>
+#include <sys/stat.h>
+#include <time.h>
 #include <unistd.h>
 
 #include <libplacebo/colorspace.h>
@@ -90,9 +93,12 @@ struct frame_info {
 };
 
 struct cache {
-    char *path;
+    struct mp_log *log;
+    struct mpv_global *global;
+    char *dir;
+    const char *name;
+    size_t size_limit;
     pl_cache cache;
-    uint64_t sig;
 };
 
 struct priv {
@@ -1515,84 +1521,210 @@ static void wait_events(struct vo *vo, int64_t until_time_ns)
     }
 }
 
-#if PL_API_VER < 342
-static inline void xor_hash(void *hash, pl_cache_obj obj)
+static char *cache_filepath(void *ta_ctx, char *dir, const char *prefix, uint64_t key)
 {
-    *((uint64_t *) hash) ^= obj.key;
+    bstr filename = {0};
+    bstr_xappend_asprintf(ta_ctx, &filename, "%s_%016" PRIx64, prefix, key);
+    return mp_path_join_bstr(ta_ctx, bstr0(dir), filename);
 }
 
-static inline uint64_t pl_cache_signature(pl_cache cache)
+static void cache_save_file(void *ta_ctx, char *filepath, void *data, size_t size)
 {
-    uint64_t hash = 0;
-    pl_cache_iterate(cache, xor_hash, &hash);
-    return hash;
+    if (!data || !size)
+        return;
+
+    char *tmp = talloc_asprintf(ta_ctx, "%sXXXXXX", filepath);
+    int fd = mkstemp(tmp);
+    if (fd < 0)
+        return;
+    FILE *cache = fdopen(fd, "wb");
+    if (!cache) {
+        close(fd);
+        unlink(tmp);
+        return;
+    }
+    size_t written = fwrite(data, size, 1, cache);
+    int ret = fclose(cache);
+    if (written > 0 && !ret) {
+        ret = rename(tmp, filepath);
+    } else {
+        unlink(tmp);
+    }
+}
+
+static pl_cache_obj cache_load_obj(void *p, uint64_t key)
+{
+    struct cache *c = p;
+    void *ta_ctx = talloc_new(NULL);
+    pl_cache_obj obj = {0};
+
+    if (!c->dir)
+        goto done;
+
+    char *filepath = cache_filepath(ta_ctx, c->dir, c->name, key);
+    if (!filepath)
+        goto done;
+
+    if (stat(filepath, &(struct stat){0}))
+        goto done;
+
+    int64_t load_start = mp_time_ns();
+    struct bstr data = stream_read_file(filepath, ta_ctx, c->global, STREAM_MAX_READ_SIZE);
+    int64_t load_end = mp_time_ns();
+    MP_DBG(c, "%s: key(%" PRIx64 "), size(%zu), load time(%.3f ms)\n",
+           __func__, key, data.len,
+           MP_TIME_NS_TO_MS(load_end - load_start));
+
+    obj = (pl_cache_obj){
+        .key = key,
+        .data = talloc_steal(NULL, data.start),
+        .size = data.len,
+        .free = talloc_free,
+    };
+
+done:
+    talloc_free(ta_ctx);
+    return obj;
+}
+
+static void cache_save_obj(void *p, pl_cache_obj obj)
+{
+    const struct cache *c = p;
+    void *ta_ctx = talloc_new(NULL);
+
+    if (!c->dir)
+        goto done;
+
+    char *filepath = cache_filepath(ta_ctx, c->dir, c->name, obj.key);
+    if (!filepath)
+        goto done;
+
+    // Don't save if already exists
+    if (!stat(filepath, &(struct stat){0})) {
+        MP_DBG(c, "%s: key(%"PRIx64"), size(%zu)\n", __func__, obj.key, obj.size);
+        goto done;
+    }
+
+    int64_t save_start = mp_time_ns();
+    cache_save_file(ta_ctx, filepath, obj.data, obj.size);
+    int64_t save_end = mp_time_ns();
+    MP_DBG(c, "%s: key(%" PRIx64 "), size(%zu), save time(%.3f ms)\n",
+           __func__, obj.key, obj.size,
+           MP_TIME_NS_TO_MS(save_end - save_start));
+
+done:
+    talloc_free(ta_ctx);
 }
-#endif
 
 static void cache_init(struct vo *vo, struct cache *cache, size_t max_size,
                        const char *dir_opt)
 {
     struct priv *p = vo->priv;
-    const char *name = cache == &p->shader_cache ? "shader.cache" : "icc.cache";
+    const char *name = cache == &p->shader_cache ? "shader" : "icc";
+    const size_t limit = cache == &p->shader_cache ? 128 << 20 : 1536 << 20;
 
     char *dir;
     if (dir_opt && dir_opt[0]) {
-        dir = mp_get_user_path(NULL, p->global, dir_opt);
+        dir = mp_get_user_path(vo, p->global, dir_opt);
     } else {
-        dir = mp_find_user_file(NULL, p->global, "cache", "");
+        dir = mp_find_user_file(vo, p->global, "cache", "");
     }
     if (!dir || !dir[0])
-        goto done;
+        return;
 
     mp_mkdirp(dir);
-    cache->path = mp_path_join(vo, dir, name);
-    cache->cache = pl_cache_create(pl_cache_params(
-        .log = p->pllog,
-        .max_total_size = max_size,
-    ));
+    *cache = (struct cache){
+        .log        = p->log,
+        .global     = p->global,
+        .dir        = dir,
+        .name       = name,
+        .size_limit = limit,
+        .cache = pl_cache_create(pl_cache_params(
+            .log = p->pllog,
+            .get = cache_load_obj,
+            .set = cache_save_obj,
+            .priv = cache
+        )),
+    };
+}
 
-    FILE *file = fopen(cache->path, "rb");
-    if (file) {
-        int ret = pl_cache_load_file(cache->cache, file);
-        fclose(file);
-        if (ret < 0)
-            MP_WARN(p, "Failed loading cache from %s\n", cache->path);
-    }
+struct file_entry {
+    char *filepath;
+    size_t size;
+    time_t atime;
+};
 
-    cache->sig = pl_cache_signature(cache->cache);
-done:
-    talloc_free(dir);
+static int compare_atime(const void *a, const void *b)
+{
+    return (((struct file_entry *)b)->atime - ((struct file_entry *)a)->atime);
 }
 
 static void cache_uninit(struct priv *p, struct cache *cache)
 {
     if (!cache->cache)
-        goto done;
-    if (pl_cache_signature(cache->cache) == cache->sig)
-        goto done; // skip re-saving identical cache
+        return;
 
-    assert(cache->path);
-    char *tmp = talloc_asprintf(cache->path, "%sXXXXXX", cache->path);
-    int fd = mkstemp(tmp);
-    if (fd < 0)
-        goto done;
-    FILE *file = fdopen(fd, "wb");
-    if (!file) {
-        close(fd);
-        unlink(tmp);
+    void *ta_ctx = talloc_new(NULL);
+    struct file_entry *files = NULL;
+    size_t num_files = 0;
+    assert(cache->dir);
+    assert(cache->name);
+
+    DIR *d = opendir(cache->dir);
+    if (!d)
         goto done;
+
+    struct dirent *dir;
+    while ((dir = readdir(d)) != NULL) {
+        char *filepath = mp_path_join(ta_ctx, cache->dir, dir->d_name);
+        if (!filepath)
+            continue;
+        struct stat filestat;
+        if (stat(filepath, &filestat))
+            continue;
+        if (!S_ISREG(filestat.st_mode))
+            continue;
+        bstr fname = bstr0(dir->d_name);
+        if (!bstr_eatstart0(&fname, cache->name))
+            continue;
+        if (fname.len != 17) // _%016x
+            continue;
+        MP_TARRAY_APPEND(ta_ctx, files, num_files,
+                         (struct file_entry){
+                             .filepath = filepath,
+                             .size     = filestat.st_size,
+                             .atime    = filestat.st_atime,
+                         });
     }
-    int ret = pl_cache_save_file(cache->cache, file);
-    fclose(file);
-    if (ret >= 0)
-        ret = rename(tmp, cache->path);
-    if (ret < 0) {
-        MP_WARN(p, "Failed saving cache to %s\n", cache->path);
-        unlink(tmp);
+    closedir(d);
+
+    if (!num_files)
+        goto done;
+
+    qsort(files, num_files, sizeof(struct file_entry), compare_atime);
+
+    time_t t = time(NULL);
+    size_t cache_size = 0;
+    size_t cache_limit = cache->size_limit ? cache->size_limit : SIZE_MAX;
+    for (int i = 0; i < num_files; i++) {
+        // Remove files that exceed the size limit but are older than one day.
+        // This allows for temporary maintaining a larger cache size while
+        // adjusting the configuration. The cache will be cleared the next day
+        // for unused entries. We don't need to be overly aggressive with cache
+        // cleaning; in most cases, it will not grow much, and in others, it may
+        // actually be useful to cache more.
+        cache_size += files[i].size;
+        double rel_use = difftime(t, files[i].atime);
+        if (cache_size > cache_limit && rel_use > 60 * 60 * 24) {
+            MP_VERBOSE(p, "Removing %s from %s cache "
+                          " | size: %9zu B | last used: %9d seconds ago\n",
+                       files[i].filepath, cache->name, files[i].size, (int)rel_use);
+            unlink(files[i].filepath);
+        }
     }
 
-    // fall through
 done:
+    talloc_free(ta_ctx);
     pl_cache_destroy(&cache->cache);
 }
 

From e45cccfb7630361b46458da4f7beb08bd9b78970 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Kacper=20Michaj=C5=82ow?= <kasper93@gmail.com>
Date: Tue, 21 Nov 2023 08:32:21 +0100
Subject: [PATCH 3/3] io: add mp_save_file

Move from vo_gpu_next.c to io.c and return result.
---
 osdep/io.c              | 29 +++++++++++++++++++++++++++++
 osdep/io.h              |  1 +
 video/out/vo_gpu_next.c | 29 ++++-------------------------
 3 files changed, 34 insertions(+), 25 deletions(-)

diff --git a/osdep/io.c b/osdep/io.c
index bdf79f8894bd..7a32e9e9f67c 100644
--- a/osdep/io.c
+++ b/osdep/io.c
@@ -902,3 +902,32 @@ int mp_mkostemps(char *template, int suffixlen, int flags)
     errno = EEXIST;
     return -1;
 }
+
+bool mp_save_to_file(const char *filepath, const void *data, size_t size)
+{
+    assert(filepath && data && size);
+
+    bool result = false;
+    char *tmp = talloc_asprintf(NULL, "%sXXXXXX", filepath);
+    int fd = mkstemp(tmp);
+    if (fd < 0)
+        goto done;
+    FILE *cache = fdopen(fd, "wb");
+    if (!cache) {
+        close(fd);
+        unlink(tmp);
+        goto done;
+    }
+    size_t written = fwrite(data, size, 1, cache);
+    int ret = fclose(cache);
+    if (written > 0 && !ret) {
+        ret = rename(tmp, filepath);
+        result = !ret;
+    } else {
+        unlink(tmp);
+    }
+
+done:
+    talloc_free(tmp);
+    return result;
+}
diff --git a/osdep/io.h b/osdep/io.h
index ca07bdbfb343..f19ad2325a33 100644
--- a/osdep/io.h
+++ b/osdep/io.h
@@ -230,5 +230,6 @@ extern char **environ;
 #endif /* __MINGW32__ */
 
 int mp_mkostemps(char *template, int suffixlen, int flags);
+bool mp_save_to_file(const char *filepath, const void *data, size_t size);
 
 #endif
diff --git a/video/out/vo_gpu_next.c b/video/out/vo_gpu_next.c
index 8a109950630a..e27c650e24b5 100644
--- a/video/out/vo_gpu_next.c
+++ b/video/out/vo_gpu_next.c
@@ -1528,30 +1528,6 @@ static char *cache_filepath(void *ta_ctx, char *dir, const char *prefix, uint64_
     return mp_path_join_bstr(ta_ctx, bstr0(dir), filename);
 }
 
-static void cache_save_file(void *ta_ctx, char *filepath, void *data, size_t size)
-{
-    if (!data || !size)
-        return;
-
-    char *tmp = talloc_asprintf(ta_ctx, "%sXXXXXX", filepath);
-    int fd = mkstemp(tmp);
-    if (fd < 0)
-        return;
-    FILE *cache = fdopen(fd, "wb");
-    if (!cache) {
-        close(fd);
-        unlink(tmp);
-        return;
-    }
-    size_t written = fwrite(data, size, 1, cache);
-    int ret = fclose(cache);
-    if (written > 0 && !ret) {
-        ret = rename(tmp, filepath);
-    } else {
-        unlink(tmp);
-    }
-}
-
 static pl_cache_obj cache_load_obj(void *p, uint64_t key)
 {
     struct cache *c = p;
@@ -1589,6 +1565,9 @@ static pl_cache_obj cache_load_obj(void *p, uint64_t key)
 
 static void cache_save_obj(void *p, pl_cache_obj obj)
 {
+    if (!obj.data || !obj.size)
+        return;
+
     const struct cache *c = p;
     void *ta_ctx = talloc_new(NULL);
 
@@ -1606,7 +1585,7 @@ static void cache_save_obj(void *p, pl_cache_obj obj)
     }
 
     int64_t save_start = mp_time_ns();
-    cache_save_file(ta_ctx, filepath, obj.data, obj.size);
+    mp_save_to_file(filepath, obj.data, obj.size);
     int64_t save_end = mp_time_ns();
     MP_DBG(c, "%s: key(%" PRIx64 "), size(%zu), save time(%.3f ms)\n",
            __func__, obj.key, obj.size,
